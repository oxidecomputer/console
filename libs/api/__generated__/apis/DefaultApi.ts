/* tslint:disable */
/* eslint-disable */
/**
 * Oxide Region API
 * API for interacting with the Oxide control plane
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: api@oxide.computer
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import {
  Disk,
  DiskFromJSON,
  DiskToJSON,
  DiskAttachment,
  DiskAttachmentFromJSON,
  DiskAttachmentToJSON,
  DiskCreateParams,
  DiskCreateParamsFromJSON,
  DiskCreateParamsToJSON,
  DiskResultsPage,
  DiskResultsPageFromJSON,
  DiskResultsPageToJSON,
  IdSortMode,
  IdSortModeFromJSON,
  IdSortModeToJSON,
  Instance,
  InstanceFromJSON,
  InstanceToJSON,
  InstanceCreateParams,
  InstanceCreateParamsFromJSON,
  InstanceCreateParamsToJSON,
  InstanceResultsPage,
  InstanceResultsPageFromJSON,
  InstanceResultsPageToJSON,
  NameOrIdSortMode,
  NameOrIdSortModeFromJSON,
  NameOrIdSortModeToJSON,
  NameSortMode,
  NameSortModeFromJSON,
  NameSortModeToJSON,
  Project,
  ProjectFromJSON,
  ProjectToJSON,
  ProjectCreateParams,
  ProjectCreateParamsFromJSON,
  ProjectCreateParamsToJSON,
  ProjectResultsPage,
  ProjectResultsPageFromJSON,
  ProjectResultsPageToJSON,
  ProjectUpdateParams,
  ProjectUpdateParamsFromJSON,
  ProjectUpdateParamsToJSON,
  Rack,
  RackFromJSON,
  RackToJSON,
  RackResultsPage,
  RackResultsPageFromJSON,
  RackResultsPageToJSON,
  Saga,
  SagaFromJSON,
  SagaToJSON,
  SagaResultsPage,
  SagaResultsPageFromJSON,
  SagaResultsPageToJSON,
  Sled,
  SledFromJSON,
  SledToJSON,
  SledResultsPage,
  SledResultsPageFromJSON,
  SledResultsPageToJSON,
  Vpc,
  VpcFromJSON,
  VpcToJSON,
  VpcCreateParams,
  VpcCreateParamsFromJSON,
  VpcCreateParamsToJSON,
  VpcResultsPage,
  VpcResultsPageFromJSON,
  VpcResultsPageToJSON,
  VpcSubnet,
  VpcSubnetFromJSON,
  VpcSubnetToJSON,
  VpcSubnetCreateParams,
  VpcSubnetCreateParamsFromJSON,
  VpcSubnetCreateParamsToJSON,
  VpcSubnetResultsPage,
  VpcSubnetResultsPageFromJSON,
  VpcSubnetResultsPageToJSON,
  VpcSubnetUpdateParams,
  VpcSubnetUpdateParamsFromJSON,
  VpcSubnetUpdateParamsToJSON,
  VpcUpdateParams,
  VpcUpdateParamsFromJSON,
  VpcUpdateParamsToJSON,
} from '../models'

export interface HardwareRacksGetRequest {
  limit?: number
  pageToken?: string
  sortBy?: IdSortMode
}

export interface HardwareRacksGetRackRequest {
  rackId: string
}

export interface HardwareSledsGetRequest {
  limit?: number
  pageToken?: string
  sortBy?: IdSortMode
}

export interface HardwareSledsGetSledRequest {
  sledId: string
}

export interface InstanceDisksDeleteDiskRequest {
  diskName: string
  instanceName: string
  projectName: string
}

export interface InstanceDisksGetRequest {
  instanceName: string
  projectName: string
}

export interface InstanceDisksGetDiskRequest {
  diskName: string
  instanceName: string
  projectName: string
}

export interface InstanceDisksPutDiskRequest {
  diskName: string
  instanceName: string
  projectName: string
}

export interface ProjectDisksDeleteDiskRequest {
  diskName: string
  projectName: string
}

export interface ProjectDisksGetRequest {
  projectName: string
  limit?: number
  pageToken?: string
  sortBy?: NameSortMode
}

export interface ProjectDisksGetDiskRequest {
  diskName: string
  projectName: string
}

export interface ProjectDisksPostRequest {
  projectName: string
  diskCreateParams: DiskCreateParams
}

export interface ProjectInstancesDeleteInstanceRequest {
  instanceName: string
  projectName: string
}

export interface ProjectInstancesGetRequest {
  projectName: string
  limit?: number
  pageToken?: string
  sortBy?: NameSortMode
}

export interface ProjectInstancesGetInstanceRequest {
  instanceName: string
  projectName: string
}

export interface ProjectInstancesInstanceRebootRequest {
  instanceName: string
  projectName: string
}

export interface ProjectInstancesInstanceStartRequest {
  instanceName: string
  projectName: string
}

export interface ProjectInstancesInstanceStopRequest {
  instanceName: string
  projectName: string
}

export interface ProjectInstancesPostRequest {
  projectName: string
  instanceCreateParams: InstanceCreateParams
}

export interface ProjectVpcsDeleteVpcRequest {
  projectName: string
  vpcName: string
}

export interface ProjectVpcsGetRequest {
  projectName: string
  limit?: number
  pageToken?: string
  sortBy?: NameSortMode
}

export interface ProjectVpcsGetVpcRequest {
  projectName: string
  vpcName: string
}

export interface ProjectVpcsPostRequest {
  projectName: string
  vpcCreateParams: VpcCreateParams
}

export interface ProjectVpcsPutVpcRequest {
  projectName: string
  vpcName: string
  vpcUpdateParams: VpcUpdateParams
}

export interface ProjectsDeleteProjectRequest {
  projectName: string
}

export interface ProjectsGetRequest {
  limit?: number
  pageToken?: string
  sortBy?: NameOrIdSortMode
}

export interface ProjectsGetProjectRequest {
  projectName: string
}

export interface ProjectsPostRequest {
  projectCreateParams: ProjectCreateParams
}

export interface ProjectsPutProjectRequest {
  projectName: string
  projectUpdateParams: ProjectUpdateParams
}

export interface SagasGetRequest {
  limit?: number
  pageToken?: string
  sortBy?: IdSortMode
}

export interface SagasGetSagaRequest {
  sagaId: string
}

export interface VpcSubnetsDeleteSubnetRequest {
  projectName: string
  subnetName: string
  vpcName: string
}

export interface VpcSubnetsGetRequest {
  projectName: string
  vpcName: string
  limit?: number
  pageToken?: string
  sortBy?: NameSortMode
}

export interface VpcSubnetsGetSubnetRequest {
  projectName: string
  subnetName: string
  vpcName: string
}

export interface VpcSubnetsPostRequest {
  projectName: string
  vpcName: string
  vpcSubnetCreateParams: VpcSubnetCreateParams
}

export interface VpcSubnetsPutSubnetRequest {
  projectName: string
  subnetName: string
  vpcName: string
  vpcSubnetUpdateParams: VpcSubnetUpdateParams
}

/**
 *
 */
export class DefaultApi extends runtime.BaseAPI {
  /**
   * List racks in the system.
   */
  async hardwareRacksGetRaw(
    requestParameters: HardwareRacksGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<RackResultsPage>> {
    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/hardware/racks`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      RackResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List racks in the system.
   */
  async hardwareRacksGet(
    requestParameters: HardwareRacksGetRequest,
    initOverrides?: RequestInit
  ): Promise<RackResultsPage> {
    const response = await this.hardwareRacksGetRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Fetch information about a particular rack.
   */
  async hardwareRacksGetRackRaw(
    requestParameters: HardwareRacksGetRackRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Rack>> {
    if (
      requestParameters.rackId === null ||
      requestParameters.rackId === undefined
    ) {
      throw new runtime.RequiredError(
        'rackId',
        'Required parameter requestParameters.rackId was null or undefined when calling hardwareRacksGetRack.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/hardware/racks/{rack_id}`.replace(
          `{${'rack_id'}}`,
          encodeURIComponent(String(requestParameters.rackId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      RackFromJSON(jsonValue)
    )
  }

  /**
   * Fetch information about a particular rack.
   */
  async hardwareRacksGetRack(
    requestParameters: HardwareRacksGetRackRequest,
    initOverrides?: RequestInit
  ): Promise<Rack> {
    const response = await this.hardwareRacksGetRackRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * List sleds in the system.
   */
  async hardwareSledsGetRaw(
    requestParameters: HardwareSledsGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<SledResultsPage>> {
    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/hardware/sleds`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SledResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List sleds in the system.
   */
  async hardwareSledsGet(
    requestParameters: HardwareSledsGetRequest,
    initOverrides?: RequestInit
  ): Promise<SledResultsPage> {
    const response = await this.hardwareSledsGetRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Fetch information about a sled in the system.
   */
  async hardwareSledsGetSledRaw(
    requestParameters: HardwareSledsGetSledRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Sled>> {
    if (
      requestParameters.sledId === null ||
      requestParameters.sledId === undefined
    ) {
      throw new runtime.RequiredError(
        'sledId',
        'Required parameter requestParameters.sledId was null or undefined when calling hardwareSledsGetSled.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/hardware/sleds/{sled_id}`.replace(
          `{${'sled_id'}}`,
          encodeURIComponent(String(requestParameters.sledId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SledFromJSON(jsonValue)
    )
  }

  /**
   * Fetch information about a sled in the system.
   */
  async hardwareSledsGetSled(
    requestParameters: HardwareSledsGetSledRequest,
    initOverrides?: RequestInit
  ): Promise<Sled> {
    const response = await this.hardwareSledsGetSledRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Detach a disk from this instance.
   */
  async instanceDisksDeleteDiskRaw(
    requestParameters: InstanceDisksDeleteDiskRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.diskName === null ||
      requestParameters.diskName === undefined
    ) {
      throw new runtime.RequiredError(
        'diskName',
        'Required parameter requestParameters.diskName was null or undefined when calling instanceDisksDeleteDisk.'
      )
    }

    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling instanceDisksDeleteDisk.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling instanceDisksDeleteDisk.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances/{instance_name}/disks/{disk_name}`
          .replace(
            `{${'disk_name'}}`,
            encodeURIComponent(String(requestParameters.diskName))
          )
          .replace(
            `{${'instance_name'}}`,
            encodeURIComponent(String(requestParameters.instanceName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Detach a disk from this instance.
   */
  async instanceDisksDeleteDisk(
    requestParameters: InstanceDisksDeleteDiskRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.instanceDisksDeleteDiskRaw(requestParameters, initOverrides)
  }

  /**
   * List disks attached to this instance.
   */
  async instanceDisksGetRaw(
    requestParameters: InstanceDisksGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Array<DiskAttachment>>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling instanceDisksGet.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling instanceDisksGet.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances/{instance_name}/disks`
          .replace(
            `{${'instance_name'}}`,
            encodeURIComponent(String(requestParameters.instanceName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(DiskAttachmentFromJSON)
    )
  }

  /**
   * List disks attached to this instance.
   */
  async instanceDisksGet(
    requestParameters: InstanceDisksGetRequest,
    initOverrides?: RequestInit
  ): Promise<Array<DiskAttachment>> {
    const response = await this.instanceDisksGetRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Fetch a description of the attachment of this disk to this instance.
   */
  async instanceDisksGetDiskRaw(
    requestParameters: InstanceDisksGetDiskRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<DiskAttachment>> {
    if (
      requestParameters.diskName === null ||
      requestParameters.diskName === undefined
    ) {
      throw new runtime.RequiredError(
        'diskName',
        'Required parameter requestParameters.diskName was null or undefined when calling instanceDisksGetDisk.'
      )
    }

    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling instanceDisksGetDisk.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling instanceDisksGetDisk.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances/{instance_name}/disks/{disk_name}`
          .replace(
            `{${'disk_name'}}`,
            encodeURIComponent(String(requestParameters.diskName))
          )
          .replace(
            `{${'instance_name'}}`,
            encodeURIComponent(String(requestParameters.instanceName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DiskAttachmentFromJSON(jsonValue)
    )
  }

  /**
   * Fetch a description of the attachment of this disk to this instance.
   */
  async instanceDisksGetDisk(
    requestParameters: InstanceDisksGetDiskRequest,
    initOverrides?: RequestInit
  ): Promise<DiskAttachment> {
    const response = await this.instanceDisksGetDiskRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Attach a disk to this instance.
   */
  async instanceDisksPutDiskRaw(
    requestParameters: InstanceDisksPutDiskRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<DiskAttachment>> {
    if (
      requestParameters.diskName === null ||
      requestParameters.diskName === undefined
    ) {
      throw new runtime.RequiredError(
        'diskName',
        'Required parameter requestParameters.diskName was null or undefined when calling instanceDisksPutDisk.'
      )
    }

    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling instanceDisksPutDisk.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling instanceDisksPutDisk.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances/{instance_name}/disks/{disk_name}`
          .replace(
            `{${'disk_name'}}`,
            encodeURIComponent(String(requestParameters.diskName))
          )
          .replace(
            `{${'instance_name'}}`,
            encodeURIComponent(String(requestParameters.instanceName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DiskAttachmentFromJSON(jsonValue)
    )
  }

  /**
   * Attach a disk to this instance.
   */
  async instanceDisksPutDisk(
    requestParameters: InstanceDisksPutDiskRequest,
    initOverrides?: RequestInit
  ): Promise<DiskAttachment> {
    const response = await this.instanceDisksPutDiskRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Delete a disk from a project.
   */
  async projectDisksDeleteDiskRaw(
    requestParameters: ProjectDisksDeleteDiskRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.diskName === null ||
      requestParameters.diskName === undefined
    ) {
      throw new runtime.RequiredError(
        'diskName',
        'Required parameter requestParameters.diskName was null or undefined when calling projectDisksDeleteDisk.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectDisksDeleteDisk.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/disks/{disk_name}`
          .replace(
            `{${'disk_name'}}`,
            encodeURIComponent(String(requestParameters.diskName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete a disk from a project.
   */
  async projectDisksDeleteDisk(
    requestParameters: ProjectDisksDeleteDiskRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.projectDisksDeleteDiskRaw(requestParameters, initOverrides)
  }

  /**
   * List disks in a project.
   */
  async projectDisksGetRaw(
    requestParameters: ProjectDisksGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<DiskResultsPage>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectDisksGet.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/disks`.replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DiskResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List disks in a project.
   */
  async projectDisksGet(
    requestParameters: ProjectDisksGetRequest,
    initOverrides?: RequestInit
  ): Promise<DiskResultsPage> {
    const response = await this.projectDisksGetRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Fetch a single disk in a project.
   */
  async projectDisksGetDiskRaw(
    requestParameters: ProjectDisksGetDiskRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Disk>> {
    if (
      requestParameters.diskName === null ||
      requestParameters.diskName === undefined
    ) {
      throw new runtime.RequiredError(
        'diskName',
        'Required parameter requestParameters.diskName was null or undefined when calling projectDisksGetDisk.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectDisksGetDisk.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/disks/{disk_name}`
          .replace(
            `{${'disk_name'}}`,
            encodeURIComponent(String(requestParameters.diskName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DiskFromJSON(jsonValue)
    )
  }

  /**
   * Fetch a single disk in a project.
   */
  async projectDisksGetDisk(
    requestParameters: ProjectDisksGetDiskRequest,
    initOverrides?: RequestInit
  ): Promise<Disk> {
    const response = await this.projectDisksGetDiskRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Create a disk in a project.  * TODO-correctness See note about instance create.  This should be async.
   */
  async projectDisksPostRaw(
    requestParameters: ProjectDisksPostRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Disk>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectDisksPost.'
      )
    }

    if (
      requestParameters.diskCreateParams === null ||
      requestParameters.diskCreateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'diskCreateParams',
        'Required parameter requestParameters.diskCreateParams was null or undefined when calling projectDisksPost.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request(
      {
        path: `/projects/{project_name}/disks`.replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: DiskCreateParamsToJSON(requestParameters.diskCreateParams),
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DiskFromJSON(jsonValue)
    )
  }

  /**
   * Create a disk in a project.  * TODO-correctness See note about instance create.  This should be async.
   */
  async projectDisksPost(
    requestParameters: ProjectDisksPostRequest,
    initOverrides?: RequestInit
  ): Promise<Disk> {
    const response = await this.projectDisksPostRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Delete an instance from a project.
   */
  async projectInstancesDeleteInstanceRaw(
    requestParameters: ProjectInstancesDeleteInstanceRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling projectInstancesDeleteInstance.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesDeleteInstance.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances/{instance_name}`
          .replace(
            `{${'instance_name'}}`,
            encodeURIComponent(String(requestParameters.instanceName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete an instance from a project.
   */
  async projectInstancesDeleteInstance(
    requestParameters: ProjectInstancesDeleteInstanceRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.projectInstancesDeleteInstanceRaw(
      requestParameters,
      initOverrides
    )
  }

  /**
   * List instances in a project.
   */
  async projectInstancesGetRaw(
    requestParameters: ProjectInstancesGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<InstanceResultsPage>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesGet.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances`.replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List instances in a project.
   */
  async projectInstancesGet(
    requestParameters: ProjectInstancesGetRequest,
    initOverrides?: RequestInit
  ): Promise<InstanceResultsPage> {
    const response = await this.projectInstancesGetRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Get an instance in a project.
   */
  async projectInstancesGetInstanceRaw(
    requestParameters: ProjectInstancesGetInstanceRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Instance>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling projectInstancesGetInstance.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesGetInstance.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances/{instance_name}`
          .replace(
            `{${'instance_name'}}`,
            encodeURIComponent(String(requestParameters.instanceName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceFromJSON(jsonValue)
    )
  }

  /**
   * Get an instance in a project.
   */
  async projectInstancesGetInstance(
    requestParameters: ProjectInstancesGetInstanceRequest,
    initOverrides?: RequestInit
  ): Promise<Instance> {
    const response = await this.projectInstancesGetInstanceRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Reboot an instance.
   */
  async projectInstancesInstanceRebootRaw(
    requestParameters: ProjectInstancesInstanceRebootRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Instance>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling projectInstancesInstanceReboot.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesInstanceReboot.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances/{instance_name}/reboot`
          .replace(
            `{${'instance_name'}}`,
            encodeURIComponent(String(requestParameters.instanceName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceFromJSON(jsonValue)
    )
  }

  /**
   * Reboot an instance.
   */
  async projectInstancesInstanceReboot(
    requestParameters: ProjectInstancesInstanceRebootRequest,
    initOverrides?: RequestInit
  ): Promise<Instance> {
    const response = await this.projectInstancesInstanceRebootRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Boot an instance.
   */
  async projectInstancesInstanceStartRaw(
    requestParameters: ProjectInstancesInstanceStartRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Instance>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling projectInstancesInstanceStart.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesInstanceStart.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances/{instance_name}/start`
          .replace(
            `{${'instance_name'}}`,
            encodeURIComponent(String(requestParameters.instanceName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceFromJSON(jsonValue)
    )
  }

  /**
   * Boot an instance.
   */
  async projectInstancesInstanceStart(
    requestParameters: ProjectInstancesInstanceStartRequest,
    initOverrides?: RequestInit
  ): Promise<Instance> {
    const response = await this.projectInstancesInstanceStartRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Halt an instance.
   */
  async projectInstancesInstanceStopRaw(
    requestParameters: ProjectInstancesInstanceStopRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Instance>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling projectInstancesInstanceStop.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesInstanceStop.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances/{instance_name}/stop`
          .replace(
            `{${'instance_name'}}`,
            encodeURIComponent(String(requestParameters.instanceName))
          )
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceFromJSON(jsonValue)
    )
  }

  /**
   * Halt an instance.
   */
  async projectInstancesInstanceStop(
    requestParameters: ProjectInstancesInstanceStopRequest,
    initOverrides?: RequestInit
  ): Promise<Instance> {
    const response = await this.projectInstancesInstanceStopRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Create an instance in a project.  * TODO-correctness This is supposed to be async.  Is that right?  We can create the instance immediately -- it\'s just not booted yet.  Maybe the boot operation is what\'s a separate operation_id.  What about the response code (201 Created vs 202 Accepted)?  Is that orthogonal?  Things can return a useful response, including an operation id, with either response code.  Maybe a \"reboot\" operation would return a 202 Accepted because there\'s no actual resource created?
   */
  async projectInstancesPostRaw(
    requestParameters: ProjectInstancesPostRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Instance>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesPost.'
      )
    }

    if (
      requestParameters.instanceCreateParams === null ||
      requestParameters.instanceCreateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceCreateParams',
        'Required parameter requestParameters.instanceCreateParams was null or undefined when calling projectInstancesPost.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request(
      {
        path: `/projects/{project_name}/instances`.replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: InstanceCreateParamsToJSON(
          requestParameters.instanceCreateParams
        ),
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceFromJSON(jsonValue)
    )
  }

  /**
   * Create an instance in a project.  * TODO-correctness This is supposed to be async.  Is that right?  We can create the instance immediately -- it\'s just not booted yet.  Maybe the boot operation is what\'s a separate operation_id.  What about the response code (201 Created vs 202 Accepted)?  Is that orthogonal?  Things can return a useful response, including an operation id, with either response code.  Maybe a \"reboot\" operation would return a 202 Accepted because there\'s no actual resource created?
   */
  async projectInstancesPost(
    requestParameters: ProjectInstancesPostRequest,
    initOverrides?: RequestInit
  ): Promise<Instance> {
    const response = await this.projectInstancesPostRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Delete a vpc from a project.
   */
  async projectVpcsDeleteVpcRaw(
    requestParameters: ProjectVpcsDeleteVpcRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectVpcsDeleteVpc.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling projectVpcsDeleteVpc.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/vpcs/{vpc_name}`
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          )
          .replace(
            `{${'vpc_name'}}`,
            encodeURIComponent(String(requestParameters.vpcName))
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete a vpc from a project.
   */
  async projectVpcsDeleteVpc(
    requestParameters: ProjectVpcsDeleteVpcRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.projectVpcsDeleteVpcRaw(requestParameters, initOverrides)
  }

  /**
   * List VPCs in a project.
   */
  async projectVpcsGetRaw(
    requestParameters: ProjectVpcsGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<VpcResultsPage>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectVpcsGet.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/vpcs`.replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      VpcResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List VPCs in a project.
   */
  async projectVpcsGet(
    requestParameters: ProjectVpcsGetRequest,
    initOverrides?: RequestInit
  ): Promise<VpcResultsPage> {
    const response = await this.projectVpcsGetRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Get a VPC in a project.
   */
  async projectVpcsGetVpcRaw(
    requestParameters: ProjectVpcsGetVpcRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Vpc>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectVpcsGetVpc.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling projectVpcsGetVpc.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/vpcs/{vpc_name}`
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          )
          .replace(
            `{${'vpc_name'}}`,
            encodeURIComponent(String(requestParameters.vpcName))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      VpcFromJSON(jsonValue)
    )
  }

  /**
   * Get a VPC in a project.
   */
  async projectVpcsGetVpc(
    requestParameters: ProjectVpcsGetVpcRequest,
    initOverrides?: RequestInit
  ): Promise<Vpc> {
    const response = await this.projectVpcsGetVpcRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Create a VPC in a project.
   */
  async projectVpcsPostRaw(
    requestParameters: ProjectVpcsPostRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Vpc>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectVpcsPost.'
      )
    }

    if (
      requestParameters.vpcCreateParams === null ||
      requestParameters.vpcCreateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcCreateParams',
        'Required parameter requestParameters.vpcCreateParams was null or undefined when calling projectVpcsPost.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request(
      {
        path: `/projects/{project_name}/vpcs`.replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: VpcCreateParamsToJSON(requestParameters.vpcCreateParams),
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      VpcFromJSON(jsonValue)
    )
  }

  /**
   * Create a VPC in a project.
   */
  async projectVpcsPost(
    requestParameters: ProjectVpcsPostRequest,
    initOverrides?: RequestInit
  ): Promise<Vpc> {
    const response = await this.projectVpcsPostRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Update a VPC.
   */
  async projectVpcsPutVpcRaw(
    requestParameters: ProjectVpcsPutVpcRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectVpcsPutVpc.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling projectVpcsPutVpc.'
      )
    }

    if (
      requestParameters.vpcUpdateParams === null ||
      requestParameters.vpcUpdateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcUpdateParams',
        'Required parameter requestParameters.vpcUpdateParams was null or undefined when calling projectVpcsPutVpc.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request(
      {
        path: `/projects/{project_name}/vpcs/{vpc_name}`
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          )
          .replace(
            `{${'vpc_name'}}`,
            encodeURIComponent(String(requestParameters.vpcName))
          ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: VpcUpdateParamsToJSON(requestParameters.vpcUpdateParams),
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Update a VPC.
   */
  async projectVpcsPutVpc(
    requestParameters: ProjectVpcsPutVpcRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.projectVpcsPutVpcRaw(requestParameters, initOverrides)
  }

  /**
   * Delete a specific project.
   */
  async projectsDeleteProjectRaw(
    requestParameters: ProjectsDeleteProjectRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectsDeleteProject.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}`.replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete a specific project.
   */
  async projectsDeleteProject(
    requestParameters: ProjectsDeleteProjectRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.projectsDeleteProjectRaw(requestParameters, initOverrides)
  }

  /**
   * List all projects.
   */
  async projectsGetRaw(
    requestParameters: ProjectsGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ProjectResultsPage>> {
    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProjectResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List all projects.
   */
  async projectsGet(
    requestParameters: ProjectsGetRequest,
    initOverrides?: RequestInit
  ): Promise<ProjectResultsPage> {
    const response = await this.projectsGetRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Fetch a specific project
   */
  async projectsGetProjectRaw(
    requestParameters: ProjectsGetProjectRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Project>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectsGetProject.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}`.replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProjectFromJSON(jsonValue)
    )
  }

  /**
   * Fetch a specific project
   */
  async projectsGetProject(
    requestParameters: ProjectsGetProjectRequest,
    initOverrides?: RequestInit
  ): Promise<Project> {
    const response = await this.projectsGetProjectRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Create a new project.
   */
  async projectsPostRaw(
    requestParameters: ProjectsPostRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Project>> {
    if (
      requestParameters.projectCreateParams === null ||
      requestParameters.projectCreateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'projectCreateParams',
        'Required parameter requestParameters.projectCreateParams was null or undefined when calling projectsPost.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request(
      {
        path: `/projects`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: ProjectCreateParamsToJSON(requestParameters.projectCreateParams),
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProjectFromJSON(jsonValue)
    )
  }

  /**
   * Create a new project.
   */
  async projectsPost(
    requestParameters: ProjectsPostRequest,
    initOverrides?: RequestInit
  ): Promise<Project> {
    const response = await this.projectsPostRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Update a specific project.  * TODO-correctness: Is it valid for PUT to accept application/json that\'s a subset of what the resource actually represents?  If not, is that a problem? (HTTP may require that this be idempotent.)  If so, can we get around that having this be a slightly different content-type (e.g., \"application/json-patch\")?  We should see what other APIs do.
   */
  async projectsPutProjectRaw(
    requestParameters: ProjectsPutProjectRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Project>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectsPutProject.'
      )
    }

    if (
      requestParameters.projectUpdateParams === null ||
      requestParameters.projectUpdateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'projectUpdateParams',
        'Required parameter requestParameters.projectUpdateParams was null or undefined when calling projectsPutProject.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request(
      {
        path: `/projects/{project_name}`.replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: ProjectUpdateParamsToJSON(requestParameters.projectUpdateParams),
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProjectFromJSON(jsonValue)
    )
  }

  /**
   * Update a specific project.  * TODO-correctness: Is it valid for PUT to accept application/json that\'s a subset of what the resource actually represents?  If not, is that a problem? (HTTP may require that this be idempotent.)  If so, can we get around that having this be a slightly different content-type (e.g., \"application/json-patch\")?  We should see what other APIs do.
   */
  async projectsPutProject(
    requestParameters: ProjectsPutProjectRequest,
    initOverrides?: RequestInit
  ): Promise<Project> {
    const response = await this.projectsPutProjectRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * List all sagas (for debugging)
   */
  async sagasGetRaw(
    requestParameters: SagasGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<SagaResultsPage>> {
    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/sagas`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SagaResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List all sagas (for debugging)
   */
  async sagasGet(
    requestParameters: SagasGetRequest,
    initOverrides?: RequestInit
  ): Promise<SagaResultsPage> {
    const response = await this.sagasGetRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Fetch information about a single saga (for debugging)
   */
  async sagasGetSagaRaw(
    requestParameters: SagasGetSagaRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Saga>> {
    if (
      requestParameters.sagaId === null ||
      requestParameters.sagaId === undefined
    ) {
      throw new runtime.RequiredError(
        'sagaId',
        'Required parameter requestParameters.sagaId was null or undefined when calling sagasGetSaga.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/sagas/{saga_id}`.replace(
          `{${'saga_id'}}`,
          encodeURIComponent(String(requestParameters.sagaId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SagaFromJSON(jsonValue)
    )
  }

  /**
   * Fetch information about a single saga (for debugging)
   */
  async sagasGetSaga(
    requestParameters: SagasGetSagaRequest,
    initOverrides?: RequestInit
  ): Promise<Saga> {
    const response = await this.sagasGetSagaRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Delete a subnet from a VPC.
   */
  async vpcSubnetsDeleteSubnetRaw(
    requestParameters: VpcSubnetsDeleteSubnetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling vpcSubnetsDeleteSubnet.'
      )
    }

    if (
      requestParameters.subnetName === null ||
      requestParameters.subnetName === undefined
    ) {
      throw new runtime.RequiredError(
        'subnetName',
        'Required parameter requestParameters.subnetName was null or undefined when calling vpcSubnetsDeleteSubnet.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling vpcSubnetsDeleteSubnet.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          )
          .replace(
            `{${'subnet_name'}}`,
            encodeURIComponent(String(requestParameters.subnetName))
          )
          .replace(
            `{${'vpc_name'}}`,
            encodeURIComponent(String(requestParameters.vpcName))
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete a subnet from a VPC.
   */
  async vpcSubnetsDeleteSubnet(
    requestParameters: VpcSubnetsDeleteSubnetRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.vpcSubnetsDeleteSubnetRaw(requestParameters, initOverrides)
  }

  /**
   * List subnets in a VPC.
   */
  async vpcSubnetsGetRaw(
    requestParameters: VpcSubnetsGetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<VpcSubnetResultsPage>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling vpcSubnetsGet.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling vpcSubnetsGet.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/vpcs/{vpc_name}/subnets`
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          )
          .replace(
            `{${'vpc_name'}}`,
            encodeURIComponent(String(requestParameters.vpcName))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      VpcSubnetResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List subnets in a VPC.
   */
  async vpcSubnetsGet(
    requestParameters: VpcSubnetsGetRequest,
    initOverrides?: RequestInit
  ): Promise<VpcSubnetResultsPage> {
    const response = await this.vpcSubnetsGetRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Get subnet in a VPC.
   */
  async vpcSubnetsGetSubnetRaw(
    requestParameters: VpcSubnetsGetSubnetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<VpcSubnet>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling vpcSubnetsGetSubnet.'
      )
    }

    if (
      requestParameters.subnetName === null ||
      requestParameters.subnetName === undefined
    ) {
      throw new runtime.RequiredError(
        'subnetName',
        'Required parameter requestParameters.subnetName was null or undefined when calling vpcSubnetsGetSubnet.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling vpcSubnetsGetSubnet.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          )
          .replace(
            `{${'subnet_name'}}`,
            encodeURIComponent(String(requestParameters.subnetName))
          )
          .replace(
            `{${'vpc_name'}}`,
            encodeURIComponent(String(requestParameters.vpcName))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      VpcSubnetFromJSON(jsonValue)
    )
  }

  /**
   * Get subnet in a VPC.
   */
  async vpcSubnetsGetSubnet(
    requestParameters: VpcSubnetsGetSubnetRequest,
    initOverrides?: RequestInit
  ): Promise<VpcSubnet> {
    const response = await this.vpcSubnetsGetSubnetRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Create a subnet in a VPC.
   */
  async vpcSubnetsPostRaw(
    requestParameters: VpcSubnetsPostRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<VpcSubnet>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling vpcSubnetsPost.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling vpcSubnetsPost.'
      )
    }

    if (
      requestParameters.vpcSubnetCreateParams === null ||
      requestParameters.vpcSubnetCreateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcSubnetCreateParams',
        'Required parameter requestParameters.vpcSubnetCreateParams was null or undefined when calling vpcSubnetsPost.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request(
      {
        path: `/projects/{project_name}/vpcs/{vpc_name}/subnets`
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          )
          .replace(
            `{${'vpc_name'}}`,
            encodeURIComponent(String(requestParameters.vpcName))
          ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: VpcSubnetCreateParamsToJSON(
          requestParameters.vpcSubnetCreateParams
        ),
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      VpcSubnetFromJSON(jsonValue)
    )
  }

  /**
   * Create a subnet in a VPC.
   */
  async vpcSubnetsPost(
    requestParameters: VpcSubnetsPostRequest,
    initOverrides?: RequestInit
  ): Promise<VpcSubnet> {
    const response = await this.vpcSubnetsPostRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }

  /**
   * Update a VPC Subnet.
   */
  async vpcSubnetsPutSubnetRaw(
    requestParameters: VpcSubnetsPutSubnetRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling vpcSubnetsPutSubnet.'
      )
    }

    if (
      requestParameters.subnetName === null ||
      requestParameters.subnetName === undefined
    ) {
      throw new runtime.RequiredError(
        'subnetName',
        'Required parameter requestParameters.subnetName was null or undefined when calling vpcSubnetsPutSubnet.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling vpcSubnetsPutSubnet.'
      )
    }

    if (
      requestParameters.vpcSubnetUpdateParams === null ||
      requestParameters.vpcSubnetUpdateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcSubnetUpdateParams',
        'Required parameter requestParameters.vpcSubnetUpdateParams was null or undefined when calling vpcSubnetsPutSubnet.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request(
      {
        path: `/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`
          .replace(
            `{${'project_name'}}`,
            encodeURIComponent(String(requestParameters.projectName))
          )
          .replace(
            `{${'subnet_name'}}`,
            encodeURIComponent(String(requestParameters.subnetName))
          )
          .replace(
            `{${'vpc_name'}}`,
            encodeURIComponent(String(requestParameters.vpcName))
          ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: VpcSubnetUpdateParamsToJSON(
          requestParameters.vpcSubnetUpdateParams
        ),
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Update a VPC Subnet.
   */
  async vpcSubnetsPutSubnet(
    requestParameters: VpcSubnetsPutSubnetRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.vpcSubnetsPutSubnetRaw(requestParameters, initOverrides)
  }
}
