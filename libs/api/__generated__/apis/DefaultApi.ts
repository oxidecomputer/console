/* tslint:disable */
/* eslint-disable */
/**
 * Oxide Region API
 * API for interacting with the Oxide control plane
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: api@oxide.computer
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import {
  Disk,
  DiskFromJSON,
  DiskToJSON,
  DiskAttachment,
  DiskAttachmentFromJSON,
  DiskAttachmentToJSON,
  DiskCreateParams,
  DiskCreateParamsFromJSON,
  DiskCreateParamsToJSON,
  DiskResultsPage,
  DiskResultsPageFromJSON,
  DiskResultsPageToJSON,
  IdSortMode,
  IdSortModeFromJSON,
  IdSortModeToJSON,
  Instance,
  InstanceFromJSON,
  InstanceToJSON,
  InstanceCreateParams,
  InstanceCreateParamsFromJSON,
  InstanceCreateParamsToJSON,
  InstanceResultsPage,
  InstanceResultsPageFromJSON,
  InstanceResultsPageToJSON,
  NameOrIdSortMode,
  NameOrIdSortModeFromJSON,
  NameOrIdSortModeToJSON,
  NameSortMode,
  NameSortModeFromJSON,
  NameSortModeToJSON,
  Project,
  ProjectFromJSON,
  ProjectToJSON,
  ProjectCreateParams,
  ProjectCreateParamsFromJSON,
  ProjectCreateParamsToJSON,
  ProjectResultsPage,
  ProjectResultsPageFromJSON,
  ProjectResultsPageToJSON,
  ProjectUpdateParams,
  ProjectUpdateParamsFromJSON,
  ProjectUpdateParamsToJSON,
  Rack,
  RackFromJSON,
  RackToJSON,
  RackResultsPage,
  RackResultsPageFromJSON,
  RackResultsPageToJSON,
  Saga,
  SagaFromJSON,
  SagaToJSON,
  SagaResultsPage,
  SagaResultsPageFromJSON,
  SagaResultsPageToJSON,
  Sled,
  SledFromJSON,
  SledToJSON,
  SledResultsPage,
  SledResultsPageFromJSON,
  SledResultsPageToJSON,
  Vpc,
  VpcFromJSON,
  VpcToJSON,
  VpcCreateParams,
  VpcCreateParamsFromJSON,
  VpcCreateParamsToJSON,
  VpcResultsPage,
  VpcResultsPageFromJSON,
  VpcResultsPageToJSON,
  VpcUpdateParams,
  VpcUpdateParamsFromJSON,
  VpcUpdateParamsToJSON,
} from '../models'

export interface HardwareRacksGetRequest {
  limit?: number
  pageToken?: string
  sortBy?: IdSortMode
}

export interface HardwareRacksGetRackRequest {
  rackId: string
}

export interface HardwareSledsGetRequest {
  limit?: number
  pageToken?: string
  sortBy?: IdSortMode
}

export interface HardwareSledsGetSledRequest {
  sledId: string
}

export interface InstanceDisksDeleteDiskRequest {
  diskName: string
  instanceName: string
  projectName: string
}

export interface InstanceDisksGetRequest {
  instanceName: string
  projectName: string
}

export interface InstanceDisksGetDiskRequest {
  diskName: string
  instanceName: string
  projectName: string
}

export interface InstanceDisksPutDiskRequest {
  diskName: string
  instanceName: string
  projectName: string
}

export interface ProjectDisksDeleteDiskRequest {
  diskName: string
  projectName: string
}

export interface ProjectDisksGetRequest {
  projectName: string
  limit?: number
  pageToken?: string
  sortBy?: NameSortMode
}

export interface ProjectDisksGetDiskRequest {
  diskName: string
  projectName: string
}

export interface ProjectDisksPostRequest {
  projectName: string
  diskCreateParams: DiskCreateParams
}

export interface ProjectInstancesDeleteInstanceRequest {
  instanceName: string
  projectName: string
}

export interface ProjectInstancesGetRequest {
  projectName: string
  limit?: number
  pageToken?: string
  sortBy?: NameSortMode
}

export interface ProjectInstancesGetInstanceRequest {
  instanceName: string
  projectName: string
}

export interface ProjectInstancesInstanceRebootRequest {
  instanceName: string
  projectName: string
}

export interface ProjectInstancesInstanceStartRequest {
  instanceName: string
  projectName: string
}

export interface ProjectInstancesInstanceStopRequest {
  instanceName: string
  projectName: string
}

export interface ProjectInstancesPostRequest {
  projectName: string
  instanceCreateParams: InstanceCreateParams
}

export interface ProjectVpcsDeleteVpcRequest {
  projectName: string
  vpcName: string
}

export interface ProjectVpcsGetRequest {
  projectName: string
  limit?: number
  pageToken?: string
  sortBy?: NameSortMode
}

export interface ProjectVpcsGetVpcRequest {
  projectName: string
  vpcName: string
}

export interface ProjectVpcsPostRequest {
  projectName: string
  vpcCreateParams: VpcCreateParams
}

export interface ProjectVpcsPutVpcRequest {
  projectName: string
  vpcName: string
  vpcUpdateParams: VpcUpdateParams
}

export interface ProjectsDeleteProjectRequest {
  projectName: string
}

export interface ProjectsGetRequest {
  limit?: number
  pageToken?: string
  sortBy?: NameOrIdSortMode
}

export interface ProjectsGetProjectRequest {
  projectName: string
}

export interface ProjectsPostRequest {
  projectCreateParams: ProjectCreateParams
}

export interface ProjectsPutProjectRequest {
  projectName: string
  projectUpdateParams: ProjectUpdateParams
}

export interface SagasGetRequest {
  limit?: number
  pageToken?: string
  sortBy?: IdSortMode
}

export interface SagasGetSagaRequest {
  sagaId: string
}

/**
 *
 */
export class DefaultApi extends runtime.BaseAPI {
  /**
   * List racks in the system.
   */
  async hardwareRacksGetRaw(
    requestParameters: HardwareRacksGetRequest
  ): Promise<runtime.ApiResponse<RackResultsPage>> {
    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/hardware/racks`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      RackResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List racks in the system.
   */
  async hardwareRacksGet(
    requestParameters: HardwareRacksGetRequest
  ): Promise<RackResultsPage> {
    const response = await this.hardwareRacksGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Fetch information about a particular rack.
   */
  async hardwareRacksGetRackRaw(
    requestParameters: HardwareRacksGetRackRequest
  ): Promise<runtime.ApiResponse<Rack>> {
    if (
      requestParameters.rackId === null ||
      requestParameters.rackId === undefined
    ) {
      throw new runtime.RequiredError(
        'rackId',
        'Required parameter requestParameters.rackId was null or undefined when calling hardwareRacksGetRack.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/hardware/racks/{rack_id}`.replace(
        `{${'rack_id'}}`,
        encodeURIComponent(String(requestParameters.rackId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      RackFromJSON(jsonValue)
    )
  }

  /**
   * Fetch information about a particular rack.
   */
  async hardwareRacksGetRack(
    requestParameters: HardwareRacksGetRackRequest
  ): Promise<Rack> {
    const response = await this.hardwareRacksGetRackRaw(requestParameters)
    return await response.value()
  }

  /**
   * List sleds in the system.
   */
  async hardwareSledsGetRaw(
    requestParameters: HardwareSledsGetRequest
  ): Promise<runtime.ApiResponse<SledResultsPage>> {
    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/hardware/sleds`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SledResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List sleds in the system.
   */
  async hardwareSledsGet(
    requestParameters: HardwareSledsGetRequest
  ): Promise<SledResultsPage> {
    const response = await this.hardwareSledsGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Fetch information about a sled in the system.
   */
  async hardwareSledsGetSledRaw(
    requestParameters: HardwareSledsGetSledRequest
  ): Promise<runtime.ApiResponse<Sled>> {
    if (
      requestParameters.sledId === null ||
      requestParameters.sledId === undefined
    ) {
      throw new runtime.RequiredError(
        'sledId',
        'Required parameter requestParameters.sledId was null or undefined when calling hardwareSledsGetSled.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/hardware/sleds/{sled_id}`.replace(
        `{${'sled_id'}}`,
        encodeURIComponent(String(requestParameters.sledId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SledFromJSON(jsonValue)
    )
  }

  /**
   * Fetch information about a sled in the system.
   */
  async hardwareSledsGetSled(
    requestParameters: HardwareSledsGetSledRequest
  ): Promise<Sled> {
    const response = await this.hardwareSledsGetSledRaw(requestParameters)
    return await response.value()
  }

  /**
   * Detach a disk from this instance.
   */
  async instanceDisksDeleteDiskRaw(
    requestParameters: InstanceDisksDeleteDiskRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.diskName === null ||
      requestParameters.diskName === undefined
    ) {
      throw new runtime.RequiredError(
        'diskName',
        'Required parameter requestParameters.diskName was null or undefined when calling instanceDisksDeleteDisk.'
      )
    }

    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling instanceDisksDeleteDisk.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling instanceDisksDeleteDisk.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/instances/{instance_name}/disks/{disk_name}`
        .replace(
          `{${'disk_name'}}`,
          encodeURIComponent(String(requestParameters.diskName))
        )
        .replace(
          `{${'instance_name'}}`,
          encodeURIComponent(String(requestParameters.instanceName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Detach a disk from this instance.
   */
  async instanceDisksDeleteDisk(
    requestParameters: InstanceDisksDeleteDiskRequest
  ): Promise<void> {
    await this.instanceDisksDeleteDiskRaw(requestParameters)
  }

  /**
   * List disks attached to this instance.
   */
  async instanceDisksGetRaw(
    requestParameters: InstanceDisksGetRequest
  ): Promise<runtime.ApiResponse<Array<DiskAttachment>>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling instanceDisksGet.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling instanceDisksGet.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/instances/{instance_name}/disks`
        .replace(
          `{${'instance_name'}}`,
          encodeURIComponent(String(requestParameters.instanceName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(DiskAttachmentFromJSON)
    )
  }

  /**
   * List disks attached to this instance.
   */
  async instanceDisksGet(
    requestParameters: InstanceDisksGetRequest
  ): Promise<Array<DiskAttachment>> {
    const response = await this.instanceDisksGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Fetch a description of the attachment of this disk to this instance.
   */
  async instanceDisksGetDiskRaw(
    requestParameters: InstanceDisksGetDiskRequest
  ): Promise<runtime.ApiResponse<DiskAttachment>> {
    if (
      requestParameters.diskName === null ||
      requestParameters.diskName === undefined
    ) {
      throw new runtime.RequiredError(
        'diskName',
        'Required parameter requestParameters.diskName was null or undefined when calling instanceDisksGetDisk.'
      )
    }

    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling instanceDisksGetDisk.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling instanceDisksGetDisk.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/instances/{instance_name}/disks/{disk_name}`
        .replace(
          `{${'disk_name'}}`,
          encodeURIComponent(String(requestParameters.diskName))
        )
        .replace(
          `{${'instance_name'}}`,
          encodeURIComponent(String(requestParameters.instanceName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DiskAttachmentFromJSON(jsonValue)
    )
  }

  /**
   * Fetch a description of the attachment of this disk to this instance.
   */
  async instanceDisksGetDisk(
    requestParameters: InstanceDisksGetDiskRequest
  ): Promise<DiskAttachment> {
    const response = await this.instanceDisksGetDiskRaw(requestParameters)
    return await response.value()
  }

  /**
   * Attach a disk to this instance.
   */
  async instanceDisksPutDiskRaw(
    requestParameters: InstanceDisksPutDiskRequest
  ): Promise<runtime.ApiResponse<DiskAttachment>> {
    if (
      requestParameters.diskName === null ||
      requestParameters.diskName === undefined
    ) {
      throw new runtime.RequiredError(
        'diskName',
        'Required parameter requestParameters.diskName was null or undefined when calling instanceDisksPutDisk.'
      )
    }

    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling instanceDisksPutDisk.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling instanceDisksPutDisk.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/instances/{instance_name}/disks/{disk_name}`
        .replace(
          `{${'disk_name'}}`,
          encodeURIComponent(String(requestParameters.diskName))
        )
        .replace(
          `{${'instance_name'}}`,
          encodeURIComponent(String(requestParameters.instanceName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DiskAttachmentFromJSON(jsonValue)
    )
  }

  /**
   * Attach a disk to this instance.
   */
  async instanceDisksPutDisk(
    requestParameters: InstanceDisksPutDiskRequest
  ): Promise<DiskAttachment> {
    const response = await this.instanceDisksPutDiskRaw(requestParameters)
    return await response.value()
  }

  /**
   * Delete a disk from a project.
   */
  async projectDisksDeleteDiskRaw(
    requestParameters: ProjectDisksDeleteDiskRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.diskName === null ||
      requestParameters.diskName === undefined
    ) {
      throw new runtime.RequiredError(
        'diskName',
        'Required parameter requestParameters.diskName was null or undefined when calling projectDisksDeleteDisk.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectDisksDeleteDisk.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/disks/{disk_name}`
        .replace(
          `{${'disk_name'}}`,
          encodeURIComponent(String(requestParameters.diskName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete a disk from a project.
   */
  async projectDisksDeleteDisk(
    requestParameters: ProjectDisksDeleteDiskRequest
  ): Promise<void> {
    await this.projectDisksDeleteDiskRaw(requestParameters)
  }

  /**
   * List disks in a project.
   */
  async projectDisksGetRaw(
    requestParameters: ProjectDisksGetRequest
  ): Promise<runtime.ApiResponse<DiskResultsPage>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectDisksGet.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/disks`.replace(
        `{${'project_name'}}`,
        encodeURIComponent(String(requestParameters.projectName))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DiskResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List disks in a project.
   */
  async projectDisksGet(
    requestParameters: ProjectDisksGetRequest
  ): Promise<DiskResultsPage> {
    const response = await this.projectDisksGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Fetch a single disk in a project.
   */
  async projectDisksGetDiskRaw(
    requestParameters: ProjectDisksGetDiskRequest
  ): Promise<runtime.ApiResponse<Disk>> {
    if (
      requestParameters.diskName === null ||
      requestParameters.diskName === undefined
    ) {
      throw new runtime.RequiredError(
        'diskName',
        'Required parameter requestParameters.diskName was null or undefined when calling projectDisksGetDisk.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectDisksGetDisk.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/disks/{disk_name}`
        .replace(
          `{${'disk_name'}}`,
          encodeURIComponent(String(requestParameters.diskName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DiskFromJSON(jsonValue)
    )
  }

  /**
   * Fetch a single disk in a project.
   */
  async projectDisksGetDisk(
    requestParameters: ProjectDisksGetDiskRequest
  ): Promise<Disk> {
    const response = await this.projectDisksGetDiskRaw(requestParameters)
    return await response.value()
  }

  /**
   * Create a disk in a project.  * TODO-correctness See note about instance create.  This should be async.
   */
  async projectDisksPostRaw(
    requestParameters: ProjectDisksPostRequest
  ): Promise<runtime.ApiResponse<Disk>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectDisksPost.'
      )
    }

    if (
      requestParameters.diskCreateParams === null ||
      requestParameters.diskCreateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'diskCreateParams',
        'Required parameter requestParameters.diskCreateParams was null or undefined when calling projectDisksPost.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request({
      path: `/projects/{project_name}/disks`.replace(
        `{${'project_name'}}`,
        encodeURIComponent(String(requestParameters.projectName))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: DiskCreateParamsToJSON(requestParameters.diskCreateParams),
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DiskFromJSON(jsonValue)
    )
  }

  /**
   * Create a disk in a project.  * TODO-correctness See note about instance create.  This should be async.
   */
  async projectDisksPost(
    requestParameters: ProjectDisksPostRequest
  ): Promise<Disk> {
    const response = await this.projectDisksPostRaw(requestParameters)
    return await response.value()
  }

  /**
   * Delete an instance from a project.
   */
  async projectInstancesDeleteInstanceRaw(
    requestParameters: ProjectInstancesDeleteInstanceRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling projectInstancesDeleteInstance.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesDeleteInstance.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/instances/{instance_name}`
        .replace(
          `{${'instance_name'}}`,
          encodeURIComponent(String(requestParameters.instanceName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete an instance from a project.
   */
  async projectInstancesDeleteInstance(
    requestParameters: ProjectInstancesDeleteInstanceRequest
  ): Promise<void> {
    await this.projectInstancesDeleteInstanceRaw(requestParameters)
  }

  /**
   * List instances in a project.
   */
  async projectInstancesGetRaw(
    requestParameters: ProjectInstancesGetRequest
  ): Promise<runtime.ApiResponse<InstanceResultsPage>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesGet.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/instances`.replace(
        `{${'project_name'}}`,
        encodeURIComponent(String(requestParameters.projectName))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List instances in a project.
   */
  async projectInstancesGet(
    requestParameters: ProjectInstancesGetRequest
  ): Promise<InstanceResultsPage> {
    const response = await this.projectInstancesGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Get an instance in a project.
   */
  async projectInstancesGetInstanceRaw(
    requestParameters: ProjectInstancesGetInstanceRequest
  ): Promise<runtime.ApiResponse<Instance>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling projectInstancesGetInstance.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesGetInstance.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/instances/{instance_name}`
        .replace(
          `{${'instance_name'}}`,
          encodeURIComponent(String(requestParameters.instanceName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceFromJSON(jsonValue)
    )
  }

  /**
   * Get an instance in a project.
   */
  async projectInstancesGetInstance(
    requestParameters: ProjectInstancesGetInstanceRequest
  ): Promise<Instance> {
    const response = await this.projectInstancesGetInstanceRaw(
      requestParameters
    )
    return await response.value()
  }

  /**
   * Reboot an instance.
   */
  async projectInstancesInstanceRebootRaw(
    requestParameters: ProjectInstancesInstanceRebootRequest
  ): Promise<runtime.ApiResponse<Instance>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling projectInstancesInstanceReboot.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesInstanceReboot.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/instances/{instance_name}/reboot`
        .replace(
          `{${'instance_name'}}`,
          encodeURIComponent(String(requestParameters.instanceName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceFromJSON(jsonValue)
    )
  }

  /**
   * Reboot an instance.
   */
  async projectInstancesInstanceReboot(
    requestParameters: ProjectInstancesInstanceRebootRequest
  ): Promise<Instance> {
    const response = await this.projectInstancesInstanceRebootRaw(
      requestParameters
    )
    return await response.value()
  }

  /**
   * Boot an instance.
   */
  async projectInstancesInstanceStartRaw(
    requestParameters: ProjectInstancesInstanceStartRequest
  ): Promise<runtime.ApiResponse<Instance>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling projectInstancesInstanceStart.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesInstanceStart.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/instances/{instance_name}/start`
        .replace(
          `{${'instance_name'}}`,
          encodeURIComponent(String(requestParameters.instanceName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceFromJSON(jsonValue)
    )
  }

  /**
   * Boot an instance.
   */
  async projectInstancesInstanceStart(
    requestParameters: ProjectInstancesInstanceStartRequest
  ): Promise<Instance> {
    const response = await this.projectInstancesInstanceStartRaw(
      requestParameters
    )
    return await response.value()
  }

  /**
   * Halt an instance.
   */
  async projectInstancesInstanceStopRaw(
    requestParameters: ProjectInstancesInstanceStopRequest
  ): Promise<runtime.ApiResponse<Instance>> {
    if (
      requestParameters.instanceName === null ||
      requestParameters.instanceName === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceName',
        'Required parameter requestParameters.instanceName was null or undefined when calling projectInstancesInstanceStop.'
      )
    }

    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesInstanceStop.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/instances/{instance_name}/stop`
        .replace(
          `{${'instance_name'}}`,
          encodeURIComponent(String(requestParameters.instanceName))
        )
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceFromJSON(jsonValue)
    )
  }

  /**
   * Halt an instance.
   */
  async projectInstancesInstanceStop(
    requestParameters: ProjectInstancesInstanceStopRequest
  ): Promise<Instance> {
    const response = await this.projectInstancesInstanceStopRaw(
      requestParameters
    )
    return await response.value()
  }

  /**
   * Create an instance in a project.  * TODO-correctness This is supposed to be async.  Is that right?  We can create the instance immediately -- it\'s just not booted yet.  Maybe the boot operation is what\'s a separate operation_id.  What about the response code (201 Created vs 202 Accepted)?  Is that orthogonal?  Things can return a useful response, including an operation id, with either response code.  Maybe a \"reboot\" operation would return a 202 Accepted because there\'s no actual resource created?
   */
  async projectInstancesPostRaw(
    requestParameters: ProjectInstancesPostRequest
  ): Promise<runtime.ApiResponse<Instance>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectInstancesPost.'
      )
    }

    if (
      requestParameters.instanceCreateParams === null ||
      requestParameters.instanceCreateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'instanceCreateParams',
        'Required parameter requestParameters.instanceCreateParams was null or undefined when calling projectInstancesPost.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request({
      path: `/projects/{project_name}/instances`.replace(
        `{${'project_name'}}`,
        encodeURIComponent(String(requestParameters.projectName))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: InstanceCreateParamsToJSON(requestParameters.instanceCreateParams),
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      InstanceFromJSON(jsonValue)
    )
  }

  /**
   * Create an instance in a project.  * TODO-correctness This is supposed to be async.  Is that right?  We can create the instance immediately -- it\'s just not booted yet.  Maybe the boot operation is what\'s a separate operation_id.  What about the response code (201 Created vs 202 Accepted)?  Is that orthogonal?  Things can return a useful response, including an operation id, with either response code.  Maybe a \"reboot\" operation would return a 202 Accepted because there\'s no actual resource created?
   */
  async projectInstancesPost(
    requestParameters: ProjectInstancesPostRequest
  ): Promise<Instance> {
    const response = await this.projectInstancesPostRaw(requestParameters)
    return await response.value()
  }

  /**
   * Delete a vpc from a project.
   */
  async projectVpcsDeleteVpcRaw(
    requestParameters: ProjectVpcsDeleteVpcRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectVpcsDeleteVpc.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling projectVpcsDeleteVpc.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/vpcs/{vpc_name}`
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        )
        .replace(
          `{${'vpc_name'}}`,
          encodeURIComponent(String(requestParameters.vpcName))
        ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete a vpc from a project.
   */
  async projectVpcsDeleteVpc(
    requestParameters: ProjectVpcsDeleteVpcRequest
  ): Promise<void> {
    await this.projectVpcsDeleteVpcRaw(requestParameters)
  }

  /**
   * List VPCs in a project.
   */
  async projectVpcsGetRaw(
    requestParameters: ProjectVpcsGetRequest
  ): Promise<runtime.ApiResponse<VpcResultsPage>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectVpcsGet.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/vpcs`.replace(
        `{${'project_name'}}`,
        encodeURIComponent(String(requestParameters.projectName))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      VpcResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List VPCs in a project.
   */
  async projectVpcsGet(
    requestParameters: ProjectVpcsGetRequest
  ): Promise<VpcResultsPage> {
    const response = await this.projectVpcsGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Get a VPC in a project.
   */
  async projectVpcsGetVpcRaw(
    requestParameters: ProjectVpcsGetVpcRequest
  ): Promise<runtime.ApiResponse<Vpc>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectVpcsGetVpc.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling projectVpcsGetVpc.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}/vpcs/{vpc_name}`
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        )
        .replace(
          `{${'vpc_name'}}`,
          encodeURIComponent(String(requestParameters.vpcName))
        ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      VpcFromJSON(jsonValue)
    )
  }

  /**
   * Get a VPC in a project.
   */
  async projectVpcsGetVpc(
    requestParameters: ProjectVpcsGetVpcRequest
  ): Promise<Vpc> {
    const response = await this.projectVpcsGetVpcRaw(requestParameters)
    return await response.value()
  }

  /**
   * Create a VPC in a project.
   */
  async projectVpcsPostRaw(
    requestParameters: ProjectVpcsPostRequest
  ): Promise<runtime.ApiResponse<Vpc>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectVpcsPost.'
      )
    }

    if (
      requestParameters.vpcCreateParams === null ||
      requestParameters.vpcCreateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcCreateParams',
        'Required parameter requestParameters.vpcCreateParams was null or undefined when calling projectVpcsPost.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request({
      path: `/projects/{project_name}/vpcs`.replace(
        `{${'project_name'}}`,
        encodeURIComponent(String(requestParameters.projectName))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: VpcCreateParamsToJSON(requestParameters.vpcCreateParams),
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      VpcFromJSON(jsonValue)
    )
  }

  /**
   * Create a VPC in a project.
   */
  async projectVpcsPost(
    requestParameters: ProjectVpcsPostRequest
  ): Promise<Vpc> {
    const response = await this.projectVpcsPostRaw(requestParameters)
    return await response.value()
  }

  /**
   * Update a VPC.
   */
  async projectVpcsPutVpcRaw(
    requestParameters: ProjectVpcsPutVpcRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectVpcsPutVpc.'
      )
    }

    if (
      requestParameters.vpcName === null ||
      requestParameters.vpcName === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcName',
        'Required parameter requestParameters.vpcName was null or undefined when calling projectVpcsPutVpc.'
      )
    }

    if (
      requestParameters.vpcUpdateParams === null ||
      requestParameters.vpcUpdateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'vpcUpdateParams',
        'Required parameter requestParameters.vpcUpdateParams was null or undefined when calling projectVpcsPutVpc.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request({
      path: `/projects/{project_name}/vpcs/{vpc_name}`
        .replace(
          `{${'project_name'}}`,
          encodeURIComponent(String(requestParameters.projectName))
        )
        .replace(
          `{${'vpc_name'}}`,
          encodeURIComponent(String(requestParameters.vpcName))
        ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: VpcUpdateParamsToJSON(requestParameters.vpcUpdateParams),
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Update a VPC.
   */
  async projectVpcsPutVpc(
    requestParameters: ProjectVpcsPutVpcRequest
  ): Promise<void> {
    await this.projectVpcsPutVpcRaw(requestParameters)
  }

  /**
   * Delete a specific project.
   */
  async projectsDeleteProjectRaw(
    requestParameters: ProjectsDeleteProjectRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectsDeleteProject.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}`.replace(
        `{${'project_name'}}`,
        encodeURIComponent(String(requestParameters.projectName))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Delete a specific project.
   */
  async projectsDeleteProject(
    requestParameters: ProjectsDeleteProjectRequest
  ): Promise<void> {
    await this.projectsDeleteProjectRaw(requestParameters)
  }

  /**
   * List all projects.
   */
  async projectsGetRaw(
    requestParameters: ProjectsGetRequest
  ): Promise<runtime.ApiResponse<ProjectResultsPage>> {
    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProjectResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List all projects.
   */
  async projectsGet(
    requestParameters: ProjectsGetRequest
  ): Promise<ProjectResultsPage> {
    const response = await this.projectsGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Fetch a specific project
   */
  async projectsGetProjectRaw(
    requestParameters: ProjectsGetProjectRequest
  ): Promise<runtime.ApiResponse<Project>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectsGetProject.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/projects/{project_name}`.replace(
        `{${'project_name'}}`,
        encodeURIComponent(String(requestParameters.projectName))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProjectFromJSON(jsonValue)
    )
  }

  /**
   * Fetch a specific project
   */
  async projectsGetProject(
    requestParameters: ProjectsGetProjectRequest
  ): Promise<Project> {
    const response = await this.projectsGetProjectRaw(requestParameters)
    return await response.value()
  }

  /**
   * Create a new project.
   */
  async projectsPostRaw(
    requestParameters: ProjectsPostRequest
  ): Promise<runtime.ApiResponse<Project>> {
    if (
      requestParameters.projectCreateParams === null ||
      requestParameters.projectCreateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'projectCreateParams',
        'Required parameter requestParameters.projectCreateParams was null or undefined when calling projectsPost.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request({
      path: `/projects`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: ProjectCreateParamsToJSON(requestParameters.projectCreateParams),
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProjectFromJSON(jsonValue)
    )
  }

  /**
   * Create a new project.
   */
  async projectsPost(requestParameters: ProjectsPostRequest): Promise<Project> {
    const response = await this.projectsPostRaw(requestParameters)
    return await response.value()
  }

  /**
   * Update a specific project.  * TODO-correctness: Is it valid for PUT to accept application/json that\'s a subset of what the resource actually represents?  If not, is that a problem? (HTTP may require that this be idempotent.)  If so, can we get around that having this be a slightly different content-type (e.g., \"application/json-patch\")?  We should see what other APIs do.
   */
  async projectsPutProjectRaw(
    requestParameters: ProjectsPutProjectRequest
  ): Promise<runtime.ApiResponse<Project>> {
    if (
      requestParameters.projectName === null ||
      requestParameters.projectName === undefined
    ) {
      throw new runtime.RequiredError(
        'projectName',
        'Required parameter requestParameters.projectName was null or undefined when calling projectsPutProject.'
      )
    }

    if (
      requestParameters.projectUpdateParams === null ||
      requestParameters.projectUpdateParams === undefined
    ) {
      throw new runtime.RequiredError(
        'projectUpdateParams',
        'Required parameter requestParameters.projectUpdateParams was null or undefined when calling projectsPutProject.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    const response = await this.request({
      path: `/projects/{project_name}`.replace(
        `{${'project_name'}}`,
        encodeURIComponent(String(requestParameters.projectName))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: ProjectUpdateParamsToJSON(requestParameters.projectUpdateParams),
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ProjectFromJSON(jsonValue)
    )
  }

  /**
   * Update a specific project.  * TODO-correctness: Is it valid for PUT to accept application/json that\'s a subset of what the resource actually represents?  If not, is that a problem? (HTTP may require that this be idempotent.)  If so, can we get around that having this be a slightly different content-type (e.g., \"application/json-patch\")?  We should see what other APIs do.
   */
  async projectsPutProject(
    requestParameters: ProjectsPutProjectRequest
  ): Promise<Project> {
    const response = await this.projectsPutProjectRaw(requestParameters)
    return await response.value()
  }

  /**
   * List all sagas (for debugging)
   */
  async sagasGetRaw(
    requestParameters: SagasGetRequest
  ): Promise<runtime.ApiResponse<SagaResultsPage>> {
    const queryParameters: any = {}

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters['page_token'] = requestParameters.pageToken
    }

    if (requestParameters.sortBy !== undefined) {
      queryParameters['sort_by'] = requestParameters.sortBy
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/sagas`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SagaResultsPageFromJSON(jsonValue)
    )
  }

  /**
   * List all sagas (for debugging)
   */
  async sagasGet(requestParameters: SagasGetRequest): Promise<SagaResultsPage> {
    const response = await this.sagasGetRaw(requestParameters)
    return await response.value()
  }

  /**
   * Fetch information about a single saga (for debugging)
   */
  async sagasGetSagaRaw(
    requestParameters: SagasGetSagaRequest
  ): Promise<runtime.ApiResponse<Saga>> {
    if (
      requestParameters.sagaId === null ||
      requestParameters.sagaId === undefined
    ) {
      throw new runtime.RequiredError(
        'sagaId',
        'Required parameter requestParameters.sagaId was null or undefined when calling sagasGetSaga.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/sagas/{saga_id}`.replace(
        `{${'saga_id'}}`,
        encodeURIComponent(String(requestParameters.sagaId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SagaFromJSON(jsonValue)
    )
  }

  /**
   * Fetch information about a single saga (for debugging)
   */
  async sagasGetSaga(requestParameters: SagasGetSagaRequest): Promise<Saga> {
    const response = await this.sagasGetSagaRaw(requestParameters)
    return await response.value()
  }
}
