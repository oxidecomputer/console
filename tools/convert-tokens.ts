import { kebabCase } from '@oxide/util'
import type { Config } from 'style-dictionary'
import StyleDictionary from 'style-dictionary'

const THEMES = ['main', 'operator-mode']

const FONT_FAMILIES = {
  'GT America Mono': '"GT America Mono", monospace',
  "Suisse Int'l":
    'SuisseIntl, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif',
}

const percentToRem = (value: string) => {
  return parseFloat(value) / 100 + 'rem'
}
const pxToRem = (value: string | number) =>
  parseFloat(value as string) / 16 + 'rem'
const valueToRem = (value: string | number) =>
  typeof value === 'string' && value.includes('%')
    ? percentToRem(value)
    : pxToRem(value)

const formatFontClass = (name: string) => {
  return name
    .replace('-light', '')
    .replace('-regular', '')
    .replace('-book', '-semi')
}

const formatStyle = (name, value) => {
  name = kebabCase(name)
  if (value === 'none') return null
  switch (name) {
    case 'font-family':
      return [name, FONT_FAMILIES[value]]
    case 'line-height':
      return value === 'AUTO' ? null : [name, valueToRem(value)]
    case 'font-weight': {
      const weight = value.toLowerCase()
      if (weight.includes('light')) {
        return [name, 300]
      } else if (weight.includes('book')) {
        return [name, 500]
      } else {
        return [name, 400]
      }
    }
    case 'paragraph-spacing':
      return null
    case 'text-case':
      return ['text-transform', value]
    case 'font-size':
    case 'letter-spacing':
      return [name, valueToRem(value)]
    default:
      return [name, value]
  }
}

StyleDictionary.registerFormat({
  name: 'theme',
  formatter({ dictionary, options }) {
    const colors = Object.fromEntries(
      dictionary.allProperties
        .filter((prop) => prop.name.startsWith('base-'))
        .map((prop) => [prop.value, prop.name])
    )
    const props = dictionary.allProperties.filter(
      (prop) => !prop.name.includes('font-families')
    )
    return `
    /* THIS FILE IS AUTOGENERATED, DO NOT EDIT */

    ${options.selector} {
      ${props
        .filter((prop) => typeof prop.value !== 'object')
        .sort(({ name }) => (name.startsWith('base-') ? -1 : 1))
        .map((prop) => {
          if (prop.value in colors && !prop.name.startsWith('base-')) {
            return `  --${prop.name}: var(--${colors[prop.value]});`
          }
          return `  --${prop.name}: ${prop.value};`
        })
        .join('\n')}
    }\n

      ${props
        .filter((prop) => prop.type === 'typography')
        .map(
          (prop) => `.text-${formatFontClass(prop.name)} {
          ${Object.entries(prop.value)
            .map(([name, value]) => formatStyle(name, value))
            .filter((style) => style !== null)
            .map(([name, value]) => `${name}: ${value};`)
            .join('\n')}
          }`
        )
        .join('\n')}`
  },
})

StyleDictionary.registerFilter({
  name: 'filter',
  matcher: (prop) => {
    return (
      ![
        'fontWeights',
        'fontSizes',
        'letterSpacing',
        'paragraphSpacing',
        'textCase',
        'textDecoration',
        'lineHeights',
        'borderRadius',
      ].includes(prop.original.type) && !prop.path.some((i) => i.includes('*'))
    )
  },
})

const makeConfig = (theme: string): Config => {
  return {
    source: [`libs/ui/styles/.tokens/${theme}.json`],
    platforms: {
      web: {
        transforms: ['attribute/cti', 'name/cti/kebab'],
        buildPath: 'libs/ui/styles/themes/',
        files: [
          {
            filter: 'filter',
            destination: `${theme}.css`,
            format: 'theme',
            options: {
              selector: theme === 'main' ? ':root' : `.${theme}-theme`,
            },
          },
        ],
      },
    },
  }
}

THEMES.map((theme) => {
  const sd = StyleDictionary.extend(makeConfig(theme))
  sd.buildPlatform('web')
})
